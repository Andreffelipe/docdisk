"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var documentationGo = {
    basic: {
        title: 'Sintaxe Básica',
        content: "\n    Hello World\n\n    File hello.go\n\n    package main\n\n    import \"fmt\"\n\n    func main () {\n      fmt.Println(\"Hello Go\")\n    }\n\n    $ go run hello.go\n    ",
    },
    operador: {
        title: 'Operadores',
        content: "\n=> Aritm\u00E9tico\n\n    |Operador |Descri\u00E7\u00E3o          |\n    |---------|-------------------|\n    |   '+ '  |adi\u00E7\u00E3o             |\n    |   '- '  |subtra\u00E7\u00E3o          |\n    |   '* '  |multiplica\u00E7\u00E3o      |\n    |   '/ '  |quociente          |\n    |   '% '  |restante           |\n    |   '& '  |bitwise and        |\n    |   '| '  |bitwise or         |\n    |   '^ '  |bitwise xor        |\n    |   '&^ ' |bit clear (and not)|\n    |   '<< ' |deslocar \u00E0 esquerda|\n    |   '>> ' |deslocar \u00E0 direita |\n\n=> Compara\u00E7\u00E3o\n\n    |Operator |Descri\u00E7\u00E3o            |\n    |---------|---------------------|\n    |  '== '  |equal                |\n    |  '!= '  |diferente            |\n    |  ' < '  |menor que            |\n    |  '<= '  |menor que ou igual   |\n    |  ' > '  |maior que            |\n    |  '>= '  |maior que ou igual   |\n\n=> Logico\n\n    |Operador |Descri\u00E7\u00E3o  |\n    |---------|-----------|\n    |  '&& '  |l\u00F3gico and |\n    |  '|| '  |l\u00F3gico or  |\n    |  ' ! '  |l\u00F3gico not |\n\n=> Outros\n\n    |Operador |Descri\u00E7\u00E3o                                     |\n    |---------|----------------------------------------------|\n    |   '& '  |endere\u00E7o de / criar ponteiro                  |\n    |   '* '  |ponteiro de desrefer\u00EAncia                     |\n    |   '<-'  |operador de envio / recebimento               |\n    ",
    },
    declaracao: {
        title: 'Declaração',
        content: "\n\n    O tipo vai depois do identificador!\n\n  - Declara\u00E7\u00E3o sem inicializa\u00E7\u00E3o\n    var foo int\n\n  - Declara\u00E7\u00E3o com inicializa\u00E7\u00E3o\n    var foo int = 42\n\n  - Declara e inicia m\u00FAltiplas vari\u00E1veis de uma vez\n    var foo, bar int = 42,1302\n\n  - Tipo omitido, ser\u00E1 inferido pelo compilador\n    var foo = 42\n\n  - Abreviadamente, apenas em corpos de fun\u00E7\u00F5es, omite a palavra-chave var, o tipo est\u00E1 sempre impl\u00EDcito\n    foo := 42\n\n    const constante string = \"eu sou uma constante\"\n    var variavel string = \"eu sou uma vari\u00E1vel\"\n\n    obs constante n\u00E3o aceita altera\u00E7\u00E3o em seu valor, use sempre contantes, caso haja a necessidade de alterar\n    seu valor troque de const para var\n\n    ",
    },
    funcoes: {
        title: 'Funções',
        content: "\n=> Declara\u00E7\u00E3o de Fun\u00E7\u00E3o\n\n  - Fun\u00E7\u00E3o simples\n      func functionName() {}\n\n  - Fun\u00E7\u00E3o com par\u00E2metro (par\u00E2metro + seu tipo)\n      func functionName(param1 string, param2 int) {}\n\n  - Fun\u00E7\u00E3o com par\u00E2metros do mesmo tipo\n      func functionName(param1, param2 int) {}\n\n  - Fun\u00E7\u00E3o com retorno (int = tipo do retorno)\n      func functionName() int {\n          return 42\n        }\n\n  - Fun\u00E7\u00E3o com mais retornos\n      func returnMulti() (int, string) {\n          return 42,\n          \"foobar\"\n        }\n      var x, str = returnMulti()\n\n  - Fun\u00E7\u00E3o com retorno nomeado\n      func returnMulti2() (n int, s string) {\n          n = 42\n          s = \"foobar\"\n          // n e s ser\u00E1 retornado\n          return\n        }\n      var x, str = returnMulti2()\n\n\n\n=> Fun\u00E7\u00F5es como valores e fechamentos Closures\n\n    func main() {\n        // atribuir uma fun\u00E7\u00E3o a um nome\n      add := func(a, b int) int {\n          return a + b\n      }\n        // use o nome para chamar a fun\u00E7\u00E3o\n      fmt.Println(add(3,4))\n    }\n\n      // Closures, lexically escopo: As fun\u00E7\u00F5es podem acessar valores que foram\n      // no escopo ao definir a fun\u00E7\u00E3o\n    func scope() func() int{\n        outer_var := 2\n        foo := func() int { return outer_var\n        }\n        return foo\n    }\n\n    func another_scope() func() int{\n        // n\u00E3o compilar\u00E1 porque outer_var e foo n\u00E3o est\u00E3o definidos neste escopo\n        outer_var = 444\n        return foo\n      }\n\n      // Closures\n    func outer() (func() int, int) {\n        outer_var := 2\n        inner := func() int {\n            outer_var += 99 // outer_var from outer scope is mutated.\n            return outer_var\n        }\n        inner()\n        return inner, outer_var // return inner func and mutated outer_var 101\n      }\n\n\n=> Variadic Functions\n\n      func main() {\n      fmt.Println(adder(1,2,3)) // 6\n      fmt.Println(adder(9,9)) // 18\n\n      nums := []int{10,20,30}\n\n      fmt.Println(adder(nums...)) // 60\n        }\n\n\n        // Usando ... antes do nome do tipo do \u00FAltimo par\u00E2metro, voc\u00EA pode indicar que ele leva zero ou mais desses par\u00E2metros.\n        // A fun\u00E7\u00E3o \u00E9 invocada como qualquer outra fun\u00E7\u00E3o, exceto que podemos passar quantos argumentos quisermos.\n      func adder(args ...int) int {\n\n      total := 0\n      for _, v := range args {\n       // Repete os argumentos seja qual for o n\u00FAmero\n        total += v\n      }\n      return total\n        }\n      ",
    },
    types: {
        title: 'Types',
        content: "\n    bool\n\n    string\n\n    int  int8  int16  int32  int64\n    uint uint8 uint16 uint32 uint64 uintptr\n\n    byte // alias for uint8\n\n    rune // alias for int32 ~= a character (Unicode code point) - very Viking\n\n    float32 float64\n\n    complex64 complex128",
    },
    conversao: {
        title: 'Conversão de tipo',
        content: "\n      var i int = 42\n      var f float64 = float64(i)\n      var u uint = uint(f)\n      // alternative syntax\n      i := 42\n      f := float64(i)\n      u := uint(f)\n      ",
    },
    packages: {
        title: 'Packages',
        content: "\n      Package declaration at top of every source file\n      Executables are in package 'main'\n      Convention: package name == last name of import path (import path 'math/ rand' => package 'rand')\n      Upper case identifier: exported (visible from other packages)\n      Lower case identifier: private (not visible from other packages)\n\n      ",
    },
    'estrutura controle': {
        title: 'Control structures',
        content: "\n=> If\n\n    func main () {\n        // Basic one\n        if x > 10 {\n          return x\n        } else if x == 10 {\n          return 10\n        } else {\n          return -x\n        }\n\n        // Voc\u00EA pode colocar uma declara\u00E7\u00E3o antes da condi\u00E7\u00E3o\n        if a := b + c; a < 42 {\n          return a\n        } else {\n          return a - 42\n        }\n\n        // Digite assertion dentro if\n        var val interface{ }\n        val = \"foo\"\n        if str, ok := val.(string); ok {\n          fmt.Println(str)\n        }\n      }\n\n=> Loops\n\n  // Existe apenas 'for', nenhum 'while', nenhum 'until'\n  for i := 1; i< 10; i++ { }\n\n  for ; i < 10; {\n    // while - loop\n  }\n\n  for i < 10  {\n    // voc\u00EA pode omitir ponto-e-v\u00EDrgula se houver apenas uma condi\u00E7\u00E3o\n  }\n\n  for {\n    // voc\u00EA pode omitir a condi\u00E7\u00E3o ~ while (true)\n  }\n\n      // use break/continue on current loop\n      // use break/continue com etiqueta no la\u00E7o externo\n  here:\n\n  for i := 0; i < 2; i++ {\n    for j := i + 1; j < 3; j++ {\n      if i == 0 {\n        continue here\n      }\n      fmt.Println(j)\n      if j == 2 {\n        break\n      }\n    }\n  }\n\n  there:\n\n  for i := 0; i < 2; i++ {\n    for j := i + 1; j < 3; j++ {\n      if j == 1 {\n        continue\n      }\n      fmt.Println(j)\n      if j == 2 {\n        break there\n      }\n    }\n  }\n\n=> Switch\n\n  // switch statement\n  switch operatingSystem {\n    case \"darwin\":\n      fmt.Println(\"Mac OS Hipster\")\n      // casos s\u00E3o interrompidos automaticamente, sem falhas por padr\u00E3o\n    case \"linux\":\n      fmt.Println(\"Linux Geek\")\n    default:\n      fmt.Println(\"Other\")\n  }\n\n\n  // como com for e if, voc\u00EA pode ter uma instru\u00E7\u00E3o de atribui\u00E7\u00E3o antes do valor de switch\n  switch os := runtime.GOOS; os {\n        case \"darwin\": ...\n  }\n\n  // voc\u00EA tamb\u00E9m pode fazer compara\u00E7\u00F5es em casos de troca\n  number:= 42\n  switch {\n    case number < 42:\n    fmt.Println(\"Smaller\")\n            case number == 42:\n    fmt.Println(\"Equal\")\n            case number > 42:\n    fmt.Println(\"Greater\")\n      }\n\n  // casos podem ser apresentados em listas separadas por v\u00EDrgulas\n  var char byte = '?'\n  switch char {\n    case ' ', '?', '&', '=', '#', '+', '%':\n      fmt.Println(\"Should escape\")\n    }\n",
    },
    'arrays slices ranges': {
        title: 'Arrays, Slices, Ranges',
        content: "\n\n=> Arrays\n\n  var a [10]int // declara um array int com comprimento 10. O comprimento do array faz parte do tipo!\n  a[3] = 42 // adicionando novo elemento\n  i := a[3] // lendo um elemento\n\n  var a = [2]int{1,2} // declarando e inicializando\n  a := [2]int{1,2} // forma abreviada\n  a := [...]int{1,2} // elipsis -> Compilador calcula o comprimento do array\n\n=> Slices\n\n  var a []int // declara uma fatia - semelhante a uma matriz, mas o comprimento n\u00E3o \u00E9 especificado\n  var a = []int {1,2,3,4} // declarar e inicializar uma fatia (apoiada pela matriz fornecida implicitamente)\n  a := []int{1,2,3,4} // forma abreviada\n  chars := []string{0: \"a\",2: \"c\",1: \"b\"} // [\"a\", \"b\", \"c\"]\n\n  var b = a[lo:hi] // cria uma fatia (visualiza\u00E7\u00E3o da matriz) do \u00EDndice lo at\u00E9 hi-1\n  var b = a[1: 4] // slice do index 1 at\u00E9 3\n  var b = a[: 3] // falta de baixo \u00EDndice implica 0\n  var b = a[3:] // falta de alto \u00EDndice implica len(a)\n\n  a =  append(a,17,3) // adiciona items ao slice a\n  c := append(a,b...) // concatena slices a and b\n\n   // criando um slice com make\n  a = make([]byte,5,5) // primeiro comprimento de arg, segunda capacidade\n  a = make([]byte,5) // capacidade e opcional\n\n    // criando um slice com um array\n  x := [3]string{\"bola\",\"carrinho\",\"peteca\"}\n  s := x[:] // a slice referencing the storage of x\n",
    },
    'operations on Arrays and Slices': {
        title: 'Operations on Arrays and Slices',
        content: "\n    'len(a)' retorna o comprimento de um array/a slice.\n\n    var a = [5]int{1,2,3,4,5}\n\n    for i, e := range a {\n      fmt.Println(\"%d\",i)\n      fmt.Println(\"%d\",e)\n    }\n\n    for _, e := range a {\n      fmt.Println(\"%d\",e)\n    }\n\n    // ... e se voc\u00EA s\u00F3 precisa do \u00EDndice\n    for i := range a {}\n\n    for range time.Tick(time.Second) {\n      // fa\u00E7a uma vez por segundo\n    }",
    },
    Maps: {
        title: 'Maps',
        content: "\n    var m map[string]int\n    m = make(map[string]int)\n    m[\"key\"] = 42\n    fmt.Println(m[\"key\"])\n\n    delete(m,\"key\")\n\n    elem, ok := m[\"key\"] // test if key \"key\" is present and retrieve it, if so\n      // map literal\n    var m = map[string]Vertex{\n      \"Bell Labs\": {40.68433,-74.39967},\n      \"Google\": {37.42202,-122.08408},\n    }\n      // iterate over map content\n    for key, value := range m {}\n\n      ",
    },
    structs: {
        title: 'Structs',
        content: "\n\n  N\u00E3o h\u00E1 classes, apenas structs. As structs semelhantes as classes podem ter m\u00E9todos.\n\n  // Uma estrutura \u00E9 um tipo. \u00C9 tamb\u00E9m uma cole\u00E7\u00E3o de campos\n\n  type Vertex struct {X, Y int}\n\n  var v = Vertex{1,2}\n  var v = Vertex{X: 1, Y: 2} //Cria uma estrutura definindo valores com chaves\n  var v = []Vertex{{1,2},{5,2},{5,5}} // Inicializar a slice of structs\n\n  // Acessando um valor\n  fmt.Printf(v.X)\n\n\n  // Voc\u00EA pode declarar m\u00E9todos em structs. A structs que voc\u00EA deseja declarar o\n  // m\u00E9todo on (o tipo de recebimento) fica entre a palavra-chave func e\n  // o nome do m\u00E9todo. A estrutura \u00E9 copiada em cada chamada de m\u00E9todo (!)\n\n  func (v Vertex) Abs() float64 {\n      return math.Sqrt(v.X*v.X + v.Y*v.Y)\n    }\n\n  // invocando um m\u00E9todo\n  v.Abs()\n\n  // Para m\u00E9todos mutantes, voc\u00EA precisa usar um ponteiro (veja abaixo) para o Struct\n  // como o tipo. Com isso, o valor da struct n\u00E3o \u00E9 copiado para a chamada do m\u00E9todo.\n  func (v *Vertex) add(n float64) {\n      v.X += n\n      v.Y += n\n    }\n\n  Estruturas an\u00F4nimas:\n  Mais barato e seguro do que usar 'map[string]interface{ }'.\n\n  point := struct {\n    X, Y int\n    }{1,2}\n",
    },
    ponteiros: {
        title: 'Pointers',
        content: "\n\n  p := Vertex{ 1, 2 } // p is a Vertex\n  q := &p // q \u00E9 um ponteiro para p Vertex\n  r := &Vertex{ 1, 2 }  // r \u00E9 um ponteiro para Vertex\n\n  // O tipo de ponteiro para um Vertex \u00E9 *Vertex\n\n  var s *Vertex = new(Vertex) // new cria um ponteiro para uma nova inst\u00E2ncia de struct\n",
    },
    interfaces: {
        title: 'Interfaces',
        content: "\n  // declara\u00E7\u00E3o de interface\n  type Awesomizer interface {\n      Awesomize() string\n    }\n\n  // tipos  n\u00E3o declaram para implementar interfaces\n  type Foo struct {}\n\n  // em vez disso, os tipos satisfazem implicitamente uma interface se implementarem todos os m\u00E9todos necess\u00E1rios\n  func (foo Foo) Awesomize() string {\n      return \"Awesome!\"\n  }\n    ",
    },
    embedding: {
        title: 'Embedding',
        content: "\n\n  N\u00E3o h\u00E1 subclasses no Go. Em vez disso, h\u00E1 incorpora\u00E7\u00E3o de interface e estrutura.\n\n    // As implementa\u00E7\u00F5es de ReadWriter devem satisfazer tanto o Reader quanto o Writer\n\n  type ReadWriter interface {\n      Reader\n      Writer\n    }\n    // O servidor exp\u00F5e todos os m\u00E9todos que o Logger possui\n\n  type Server struct {\n      Host string\n      Port int\n      *log.Logger\n    }\n\n    // inicialize o tipo incorporado da maneira usual\n  server := &Server{\n      \"localhost\",\n      80, log.New(...)\n    }\n\n    // m\u00E9todos implementados na estrutura incorporada s\u00E3o passados \u200B\u200Bpor\n  server.Log(...) // calls server.Logger.Log(...)\n\n  // o nome do campo do tipo incorporado \u00E9 o nome do seu tipo (neste caso, Logger)\n  var logger *log.Logger = server.Logger\n    ",
    },
    errors: {
        title: 'Errors',
        content: "\n    N\u00E3o h\u00E1 tratamento de exce\u00E7\u00E3o. As fun\u00E7\u00F5es que podem produzir um erro apenas declaram um valor de retorno adicional do tipo 'Erro'. Esta \u00E9 a interface de 'Erro':\n\n    type error interface {\n        Error() string\n      }\n\n    Uma fun\u00E7\u00E3o que pode retornar um erro:\n\n    func doStuff() (int, error) {}\n\n    func main() {\n        result, err := doStuff()\n        if err != nil {\n          // handle error\n        } else {\n          // all is good, use result\n        }\n      }\n",
    },
    concurrency: {
        title: 'Concurrency',
        content: "\n    => Goroutines\n\n  Goroutines s\u00E3o threads leves (gerenciados por Go, n\u00E3o threads de sistema operacional).\n  'go f (a, b)' inicia um novo goroutine que executa 'f' (dado que 'f' \u00E9 uma fun\u00E7\u00E3o).\n\n  // apenas uma fun\u00E7\u00E3o (que pode ser iniciada posteriormente como uma goroutine)\n  func doStuff(s string) {}\n\n  func main() {\n      // usando uma fun\u00E7\u00E3o nomeada em um goroutine\n      go doStuff(\"foobar\")\n\n      // usando uma fun\u00E7\u00E3o interna an\u00F4nima em um goroutine\n      go func (x int) {\n        // o corpo da fun\u00E7\u00E3o vai aqui\n      }(42)\n    }\n\n=> Channels\n\n  ch := make(chan int) // cria um channel do tipo int\n  ch <- 42 // Envie um valor para o channel ch.\n  v := <-ch // Receba um valor de ch\n\n  // Bloco de canais sem buffer. Leia os blocos quando nenhum valor estiver dispon\u00EDvel, escreva os blocos at\u00E9 que haja uma leitura.\n\n  // Crie um canal com buffer. A grava\u00E7\u00E3o em canais com buffer n\u00E3o bloqueia se menos de <tamanho do buffer> valores n\u00E3o lidos forem gravados\n  ch := make(chan int,\n    100)\n\n  close(ch) // fecha o canal (apenas o remetente deve fechar)\n\n  // leia do canal e teste se ele foi fechado\n  v, ok := <-ch\n\n  // se ok for falso, o canal foi fechado\n\n  // Leia do canal at\u00E9 que seja fechado\n  for i := range ch {\n      fmt.Println(i)\n    }\n\n  // selecionar blocos em opera\u00E7\u00F5es de m\u00FAltiplos canais, se um desbloquear, o caso correspondente \u00E9 executado\n  func doStuff(channelOut, channelIn chan int) {\n      select {\n      case channelOut <- 42:\n          fmt.Println(\"We could write to channelOut!\")\n      case x := <- channelIn:\n          fmt.Println(\"We could read from channelIn\")\n      case <-time.After(time.Second * 1):\n          fmt.Println(\"timeout\")\n      }\n    }\n\n=> Channel Axioms\n  - Um envio para um canal nulo bloqueia para sempre\n\n    var c chan string\n    c <- \"Hello, World!\"\n    // fatal error: all goroutines are asleep - deadlock!\n\n  - Uma recep\u00E7\u00E3o de um canal nulo bloqueia para sempre\n\n    var c chan string\n    fmt.Println(<-c)\n    // fatal error: all goroutines are asleep - deadlock!\n\n  - Um enviar para um fechado channel panics\n\n    var c = make(chan string,\n    1)\n    c <- \"Hello, World!\"\n    close(c)\n    c <- \"Hello, Panic!\"\n    // panic: enviar em canal fechado\n\n  - Uma recep\u00E7\u00E3o de um canal fechado retorna o valor zero imediatamente\n\n    var c = make(chan int,\n    2)\n    c <- 1\n    c <- 2\n    close(c)\n    for i := 0; i < 3; i++ {\n        fmt.Printf(\"%d \", <-c)\n    }\n    // 1 2 0",
    },
    printing: {
        title: 'Printing',
        content: "\n    fmt.Println(\"Hello, \u4F60\u597D, \u0928\u092E\u0938\u094D\u0924\u0947, \u041F\u0440\u0438\u0432\u0435\u0442, \u13A3\u13CF\u13F2\") // impress\u00E3o b\u00E1sica, mais nova linha\n      p := struct { X, Y int}{17,2}\n\n      fmt.Println( \"My point:\", p,\"x coord=\", p.X ) // print structs, ints, etc\n      s := fmt.Sprintln( \"My point:\", p,\"x coord=\", p.X ) // imprimir para vari\u00E1vel de string\n\n      fmt.Printf(\"%d hex:%x bin:%b fp:%f sci:%e\",17,17,17,17.0,17.0) // c-ish format\n\n      s2 := fmt.Sprintf( \"%d %f\",17,17.0 ) // impress\u00E3o formatada para vari\u00E1vel de string\n\n      hellomsg :=`\n      \"Hello\" in Chinese is \u4F60\u597D ('Ni Hao')\n       \"Hello\" in Hindi is \u0928\u092E\u0938\u094D\u0924\u0947 ('Namaste')\n      `\n\n       // literal de string multilinha, usando back-tick no in\u00EDcio e no final\n    ",
    },
    reflection: {
        title: 'Reflexão',
        content: "\n=> Chave de tipo\n\n  Um switch de tipo \u00E9 como uma instru\u00E7\u00E3o switch regular, mas os casos em um switch de tipo especificam tipos (n\u00E3o valores),\n  e esses valores s\u00E3o comparados com o tipo do valor mantido pelo valor de interface fornecido.\n\n    func do(i interface{}) {\n      switch v := i.(type) {\n      case int:\n        fmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n      case string:\n        fmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n      default:\n        fmt.Printf(\"I don't know about type %T!\\n\", v)\n        }\n      }\n\n    func main() {\n      do(21)\n      do(\"hello\")\n      do(true)\n      }\n\n    ",
    },
    snippets: {
        title: 'Snippets',
        content: "\n=> HTTP Server\n\n    package main\n\n    import (\n        \"fmt\"\n        \"net/http\"\n    )\n\n    // define a type for the response\n    type Hello struct{}\n      // let that type implement the ServeHTTP method (defined in interface http.Handler)\n    func (h Hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n        fmt.Fprint(w,\n        \"Hello!\")\n      }\n\n    func main() {\n        var h Hello\n        http.ListenAndServe(\"localhost:4000\", h)\n      }\n    \"  // Here's the method signature of http.ServeHTTP:\",\n      // type Handler interface {\n      //     ServeHTTP(w http.ResponseWriter, r *http.Request)\n      // }",
    },
    reference: {
        title: 'a8m',
        content: 'https://github.com/a8m/golang-cheat-sheet',
    },
};
exports.default = documentationGo;
