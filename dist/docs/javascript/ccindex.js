"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var documentationJS = {
    introducao: {
        title: "Introdução",
        content: "\n    Princ\u00EDpios da Engenharia de Software, do livro de Robert C. Martin C\u00F3digo Limpo, adaptados para JavaScript. Isto n\u00E3o \u00E9 um guia de estilos. \u00C9 um guia para se produzir c\u00F3digo leg\u00EDvel, reutiliz\u00E1vel e refator\u00E1vel em JavaScript.\n\n    Nem todo princ\u00EDpio demonstrado deve ser seguido rigorosamente, e ainda menos s\u00E3o os que possuem consenso universal. S\u00E3o orienta\u00E7\u00F5es e nada mais, entretanto, foram usadas em c\u00F3digo durante muitos anos de experi\u00EAncia coletiva pelos autores de C\u00F3digo limpo.\n     \n    Nosso of\u00EDcio de engenharia de software tem pouco mais de 50 anos e ainda estamos aprendendo muito. Quando a arquitetura de software for t\u00E3o velha quanto a pr\u00F3pria arquitetura, talvez ent\u00E3o tenhamos regras mais r\u00EDgidas para seguir. Por enquanto, deixe que estas orienta\u00E7\u00F5es sirvam como crit\u00E9rio para se avaliar a qualidade de c\u00F3digo JavaScript que tanto voc\u00EA e o seu time produzirem.\n     \n    Mais uma coisa: aprender isto n\u00E3o ir\u00E1 lhe transformar imediatamente em um desenvolvedor de software melhor e trabalhar com eles por muitos anos n\u00E3o quer dizer que voc\u00EA n\u00E3o cometer\u00E1 erros. Toda por\u00E7\u00E3o de c\u00F3digo come\u00E7a com um rascunho, como argila molhada sendo moldada em sua forma final. Finalmente, talhamos as imperfei\u00E7\u00F5es quando revisamos com nossos colegas. N\u00E3o se bata pelos primeiros rascunhos que ainda precisam de melhorias. Ao inv\u00E9s, bata em seu c\u00F3digo.\n     "
    },
    variaveis: {
        title: "Variáveis",
        content: "\n     Vari\u00E1veis\n     Use nomes de vari\u00E1veis que tenham significado e sejam pronunci\u00E1veis\n     Ruim:\n     \n     const yyyymmdstr = moment().format('YYYY/MM/DD');\n     Bom:\n     \n     const currentDate = moment().format('YYYY/MM/DD');\n     \n     Use o mesmo vocabul\u00E1rio para o mesmo tipo de vari\u00E1vel\n     Ruim:\n     \n     getUserInfo();\n     getClientData();\n     getCustomerRecord();\n     Bom:\n     \n     getUser();\n     \n     Use nomes pesquis\u00E1veis\n     N\u00F3s iremos ler mais c\u00F3digo que escrever. \u00C9 importante que o c\u00F3digo que escrevemos seja leg\u00EDvel e pesquis\u00E1vel. N\u00E3o dando nomes em vari\u00E1veis que sejam significativos para entender nosso programa, machucamos nossos leitores. Torne seus nomes pesquis\u00E1veis. Ferramentas como buddy.js e ESLint podem ajudar a identificar constantes sem nome.\n     \n     Ruim:\n     \n     // Para que diabos serve 86400000?\n     setTimeout(blastOff, 86400000);\n     Bom:\n     \n     // Declare-as como 'const' global em letras mai\u00FAsculas.\n     const MILLISECONDS_IN_A_DAY = 86400000;\n     \n     setTimeout(blastOff, MILLISECONDS_IN_A_DAY);\n     \n     Use vari\u00E1veis explicativas\n     Ruim:\n     \n     const address = 'One Infinite Loop, Cupertino 95014';\n     const cityZipCodeRegex = /^[^,\\]+[,\\\\s]+(.+?)\\s*(\\d{5})?$/;\n     saveCityZipCode(address.match(cityZipCodeRegex)[1], address.match(cityZipCodeRegex)[2]);\n     Bom:\n     \n     const address = 'One Infinite Loop, Cupertino 95014';\n     const cityZipCodeRegex = /^[^,\\]+[,\\\\s]+(.+?)\\s*(\\d{5})?$/;\n     const [, city, zipCode] = address.match(cityZipCodeRegex) || [];\n     saveCityZipCode(city, zipCode);\n     \n     Evite Mapeamento Mental\n     Explicito \u00E9 melhor que impl\u00EDcito.\n     \n     Ruim:\n     \n     const locations = ['Austin', 'New York', 'San Francisco'];\n     locations.forEach((l) => {\n       doStuff();\n       doSomeOtherStuff();\n       // ...\n       // ...\n       // ...\n       // Espera, para que serve o 'l' mesmo?\n       dispatch(l);\n     });\n     Bom:\n     \n     const locations = ['Austin', 'New York', 'San Francisco'];\n     locations.forEach((location) => {\n       doStuff();\n       doSomeOtherStuff();\n       // ...\n       // ...\n       // ...\n       dispatch(location);\n     });\n     \n     N\u00E3o adicione contextos desnecess\u00E1rios\n     Se o nome de sua classe/objeto j\u00E1 lhe diz alguma coisa, n\u00E3o as repita nos nomes de suas vari\u00E1veis.\n     \n     Ruim:\n     \n     const Car = {\n       carMake: 'Honda',\n       carModel: 'Accord',\n       carColor: 'Blue'\n     };\n     \n     function paintCar(car) {\n       car.carColor = 'Red';\n     }\n     Bom:\n     \n     const Car = {\n       make: 'Honda',\n       model: 'Accord',\n       color: 'Blue'\n     };\n     \n     function paintCar(car) {\n       car.color = 'Red';\n     }\n     \n     Use argumentos padr\u00F5es ao inv\u00E9s de curto circuitar ou usar condicionais\n     Argumentos padr\u00F5es s\u00E3o geralmente mais limpos do que curto circuitos. Esteja ciente que se voc\u00EA us\u00E1-los, sua fun\u00E7\u00E3o apenas ir\u00E1 fornecer valores padr\u00F5es para argumentos undefined. Outros valores \"falsos\" como '', \"\", false, null, 0, e NaN, n\u00E3o ser\u00E3o substituidos por valores padr\u00F5es.\n     \n     Ruim:\n     \n     function createMicrobrewery(name) {\n       const breweryName = name || 'Hipster Brew Co.';\n       // ...\n     }\n     Bom:\n     \n     function createMicrobrewery(breweryName = 'Hipster Brew Co.') {\n       // ...\n     }\n     ",
    },
    funcoes: {
        title: 'Funções',
        content: "\n    Fun\u00E7\u00F5es\n    Argumentos de fun\u00E7\u00F5es (idealmente 2 ou menos)\n    Limitar a quantidade de par\u00E2metros de uma fun\u00E7\u00E3o \u00E9 incrivelmente importante porque torna mais f\u00E1cil test\u00E1-la. Ter mais que tr\u00EAs leva a uma explos\u00E3o combinat\u00F3ria onde voc\u00EA tem que testar muitos casos diferentes com cada argumento separadamente.\n\n    Um ou dois argumentos \u00E9 o caso ideal, e tr\u00EAs devem ser evitados se poss\u00EDvel. Qualquer coisa a mais que isso deve ser consolidada. Geralmente, se voc\u00EA tem mais que dois argumentos ent\u00E3o sua fun\u00E7\u00E3o est\u00E1 tentando fazer muitas coisas. Nos casos em que n\u00E3o est\u00E1, na maioria das vezes um objeto \u00E9 suficiente como argumento.\n\n    J\u00E1 que JavaScript lhe permite criar objetos instantaneamente, sem ter que escrever muita coisa, voc\u00EA pode usar um objeto se voc\u00EA se pegar precisando usar muitos argumentos.\n\n    Para tornar mais \u00F3bvio quais as propriedades que as fun\u00E7\u00F5es esperam, voc\u00EA pode usar a sintaxe de desestrutura\u00E7\u00E3o (destructuring) do ES2015/ES6. Ela possui algumas vantagens:\n\n    Quando algu\u00E9m olha para a assinatura de uma fun\u00E7\u00E3o, fica imediatamente claro quais propriedades s\u00E3o usadas.\n    Desestrutura\u00E7\u00E3o tamb\u00E9m clona os valores primitivos espec\u00EDficos do objeto passado como argumento para a fun\u00E7\u00E3o. Isso pode ajudar a evitar efeitos colaterais. Nota: objetos e vetores que s\u00E3o desestruturados a partir do objeto passado por argumento N\u00C3O s\u00E3o clonados.\n    Linters podem te alertar sobre propriedades n\u00E3o utilizadas, o que seria imposs\u00EDvel sem usar desestrutura\u00E7\u00E3o.\n    Ruim:\n\n    function createMenu(title, body, buttonText, cancellable) {\n      // ...\n    }\n    Bom:\n\n    function createMenu({ title, body, buttonText, cancellable }) {\n      // ...\n    }\n\n    createMenu({\n      title: 'Foo',\n      body: 'Bar',\n      buttonText: 'Baz',\n      cancellable: true\n    });\n\n    Fun\u00E7\u00F5es devem fazer uma coisa\n    Essa \u00E9 de longe a regra mais importante em engenharia de software. Quando fun\u00E7\u00F5es fazem mais que uma coisa, elas se tornam dif\u00EDceis de serem compostas, testadas e raciocinadas. Quando voc\u00EA pode isolar uma fun\u00E7\u00E3o para realizar apenas uma a\u00E7\u00E3o, elas podem ser refatoradas facilmente e seu c\u00F3digo ficar\u00E1 muito mais limpo. Se voc\u00EA n\u00E3o levar mais nada desse guia al\u00E9m disso, voc\u00EA j\u00E1 estar\u00E1 na frente de muitos desenvolvedores.\n\n    Ruim:\n\n    function emailClients(clients) {\n      clients.forEach((client) => {\n        const clientRecord = database.lookup(client);\n        if (clientRecord.isActive()) {\n          email(client);\n        }\n      });\n    }\n    Bom:\n\n    function emailActiveClients(clients) {\n      clients\n        .filter(isActiveClient)\n        .forEach(email);\n    }\n\n    function isActiveClient(client) {\n      const clientRecord = database.lookup(client);\n      return clientRecord.isActive();\n    }\n\n    Nomes de fun\u00E7\u00F5es devem dizer o que elas fazem\n    Ruim:\n\n    function addToDate(date, month) {\n      // ...\n    }\n\n    const date = new Date();\n\n    // \u00C9 dif\u00EDcil dizer pelo nome da fun\u00E7\u00E3o o que \u00E9 adicionado\n    addToDate(date, 1);\n    Bom:\n\n    function addMonthToDate(month, date) {\n      // ...\n    }\n\n    const date = new Date();\n    addMonthToDate(1, date);\n\n    Fun\u00E7\u00F5es devem ter apenas um n\u00EDvel de abstra\u00E7\u00E3o\n    Quando voc\u00EA tem mais de um n\u00EDvel de abstra\u00E7\u00E3o sua fun\u00E7\u00E3o provavelmente esta fazendo coisas demais. Dividir suas fun\u00E7\u00F5es leva a reutiliza\u00E7\u00E3o e testes mais f\u00E1ceis.\n\n    Ruim:\n\n    function parseBetterJSAlternative(code) {\n      const REGEXES = [\n        // ...\n      ];\n\n      const statements = code.split(' ');\n      const tokens = [];\n      REGEXES.forEach((REGEX) => {\n        statements.forEach((statement) => {\n          // ...\n        });\n      });\n\n      const ast = [];\n      tokens.forEach((token) => {\n        // lex...\n      });\n\n      ast.forEach((node) => {\n        // parse...\n      });\n    }\n    Bom:\n\n    function tokenize(code) {\n      const REGEXES = [\n        // ...\n      ];\n\n      const statements = code.split(' ');\n      const tokens = [];\n      REGEXES.forEach((REGEX) => {\n        statements.forEach((statement) => {\n          tokens.push( /* ... */ );\n        });\n      });\n\n      return tokens;\n    }\n\n    function lexer(tokens) {\n      const ast = [];\n      tokens.forEach((token) => {\n        ast.push( /* ... */ );\n      });\n\n      return ast;\n    }\n\n    function parseBetterJSAlternative(code) {\n      const tokens = tokenize(code);\n      const ast = lexer(tokens);\n      ast.forEach((node) => {\n        // parse...\n      });\n    }\n\n    Remova c\u00F3digo duplicado\n    Fa\u00E7a absolutamente seu melhor para evitar c\u00F3digo duplicado. C\u00F3digo duplicado quer dizer que existe mais de um lugar onde voc\u00EA dever\u00E1 alterar algo se precisar mudar alguma l\u00F3gica.\n\n    Imagine que voc\u00EA \u00E9 dono de um restaurante e voc\u00EA toma conta do seu estoque: todos os seus tomates, cebolas, alhos, temperos, etc. Se voc\u00EA tem multiplas listas onde guarda estas informa\u00E7\u00F5es, ent\u00E3o voc\u00EA ter\u00E1 que atualizar todas elas quando servir um prato que tenha tomates. Se voc\u00EA tivesse apenas uma lista, teria apenas um lugar para atualizar!\n\n    Frequentemente, voc\u00EA possui c\u00F3digo duplicado porque voc\u00EA tem duas ou mais coisas levemente diferentes, que possuem muito em comum, mas suas diferen\u00E7as lhe for\u00E7am a ter mais duas ou tr\u00EAs fun\u00E7\u00F5es que fazem muito das mesmas coisas. Remover c\u00F3digo duplicado significa criar uma abstra\u00E7\u00E3o que seja capaz de lidar com este conjunto de coisas diferentes com apenas uma fun\u00E7\u00E3o/m\u00F3dulo/classe.\n\n    Conseguir a abstra\u00E7\u00E3o correta \u00E9 cr\u00EDtico, por isso que voc\u00EA deveria seguir os princ\u00EDpios SOLID descritos na se\u00E7\u00E3o Classes. Abstra\u00E7\u00F5es ruins podem ser piores do que c\u00F3digo duplicado, ent\u00E3o tome cuidado! Dito isto, se voc\u00EA puder fazer uma boa abstra\u00E7\u00E3o, fa\u00E7a-a! N\u00E3o repita a si mesmo, caso contr\u00E1rio voc\u00EA se pegar\u00E1 atualizando muitos lugares toda vez que precisar mudar qualquer coisinha.\n\n    Ruim:\n\n    function showDeveloperList(developers) {\n      developers.forEach((developer) => {\n        const expectedSalary = developer.calculateExpectedSalary();\n        const experience = developer.getExperience();\n        const githubLink = developer.getGithubLink();\n        const data = {\n          expectedSalary,\n          experience,\n          githubLink\n        };\n\n        render(data);\n      });\n    }\n\n    function showManagerList(managers) {\n      managers.forEach((manager) => {\n        const expectedSalary = manager.calculateExpectedSalary();\n        const experience = manager.getExperience();\n        const portfolio = manager.getMBAProjects();\n        const data = {\n          expectedSalary,\n          experience,\n          portfolio\n        };\n\n        render(data);\n      });\n    }\n    Bom:\n\n    function showEmployeeList(employees) {\n      employees.forEach((employee) => {\n        const expectedSalary = employee.calculateExpectedSalary();\n        const experience = employee.getExperience();\n\n        const data = {\n          expectedSalary,\n          experience\n        };\n\n        switch(employee.type){\n          case 'manager':\n            data.portfolio = employee.getMBAProjects();\n            break;\n          case 'developer':\n            data.githubLink = employee.getGithubLink();\n            break;\n        }\n\n        render(data);\n      });\n    }\n\n    Defina (set) objetos padr\u00F5es com Object.assign\n    Ruim:\n\n    const menuConfig = {\n      title: null,\n      body: 'Bar',\n      buttonText: null,\n      cancellable: true\n    };\n\n    function createMenu(config) {\n      config.title = config.title || 'Foo';\n      config.body = config.body || 'Bar';\n      config.buttonText = config.buttonText || 'Baz';\n      config.cancellable = config.cancellable !== undefined ? config.cancellable : true;\n    }\n\n    createMenu(menuConfig);\n    Bom:\n\n    const menuConfig = {\n      title: 'Order',\n      // Usu\u00E1rio n\u00E3o incluiu a chave 'body'\n      buttonText: 'Send',\n      cancellable: true\n    };\n\n    function createMenu(config) {\n      config = Object.assign({\n        title: 'Foo',\n        body: 'Bar',\n        buttonText: 'Baz',\n        cancellable: true\n      }, config);\n\n      // configura\u00E7\u00E3o agora \u00E9: {title: \"Order\", body: \"Bar\", buttonText: \"Send\", cancellable: true}\n      // ...\n    }\n\n    createMenu(menuConfig);\n\n    N\u00E3o use flags como par\u00E2metros de fun\u00E7\u00F5es\n    Flags falam para o seu usu\u00E1rio que sua fun\u00E7\u00E3o faz mais de uma coisa. Fun\u00E7\u00F5es devem fazer apenas uma coisa. Divida suas fun\u00E7\u00F5es se elas est\u00E3o seguindo caminhos de c\u00F3digo diferentes baseadas em um valor boleano.\n\n    Ruim:\n\n    function createFile(name, temp) {\n      if (temp) {\n        fs.create('./temp/${name}'');\n      } else {\n        fs.create(name);\n      }\n    }\n    Bom:\n\n    function createFile(name) {\n      fs.create(name);\n    }\n\n    function createTempFile(name) {\n      createFile('./temp/${name}');\n    }\n\n    Evite Efeitos Colaterais (parte 1)\n    Uma fun\u00E7\u00E3o produz um efeito colateral se ela faz alguma coisa que n\u00E3o seja receber um valor de entrada e retornar outro(s) valor(es). Um efeito colateral pode ser escrever em um arquivo, modificar uma vari\u00E1vel global, ou acidentalmente transferir todo seu dinheiro para um estranho.\n\n    Agora, voc\u00EA precisa de efeitos colaterais ocasionalmente no seu programa. Como no exemplo anterior, voc\u00EA pode precisar escrever em um arquivo. O que voc\u00EA quer fazer \u00E9 centralizar aonde est\u00E1 fazendo isto. N\u00E3o tenha diversas fun\u00E7\u00F5es e classes que escrevam para um arquivo em particular. Tenha um servi\u00E7o que fa\u00E7a isso. Um e apenas um.\n\n    O ponto principal \u00E9 evitar armadilhas como compartilhar o estado entre objetos sem nenhuma estrutura, usando tipos de dados mut\u00E1veis que podem ser escritos por qualquer coisa, e n\u00E3o centralizando onde seu efeito colateral acontece. Se voc\u00EA conseguir fazer isto, voc\u00EA ser\u00E1 muito mais feliz que a grande maioria dos outros programadores.\n\n    Ruim:\n\n    // Vari\u00E1vel global referenciada pela fun\u00E7\u00E3o seguinte\n    // Se tiv\u00E9ssemos outra fun\u00E7\u00E3o que usa esse nome, ent\u00E3o seria um vetor (array) e poderia quebrar seu c\u00F3digo\n    let name = 'Ryan McDermott';\n\n    function splitIntoFirstAndLastName() {\n      name = name.split(' ');\n    }\n\n    splitIntoFirstAndLastName();\n\n    console.log(name); // ['Ryan', 'McDermott'];\n    Bom:\n\n    function splitIntoFirstAndLastName(name) {\n      return name.split(' ');\n    }\n\n    const name = 'Ryan McDermott';\n    const newName = splitIntoFirstAndLastName(name);\n\n    console.log(name); // 'Ryan McDermott';\n    console.log(newName); // ['Ryan', 'McDermott'];\n\n    Evite Efeitos Colaterais (parte 2)\n    Em JavaScript, tipos primitivos s\u00E3o passados por valor e objetos/vetores s\u00E3o passados por refer\u00EAncia. No caso de objetos e vetores, se sua fun\u00E7\u00E3o faz uma mudan\u00E7a em um vetor de um carrinho de compras, por exemplo, adicionando um item para ser comprado, ent\u00E3o qualquer outra fun\u00E7\u00E3o que use o vetor cart tamb\u00E9m ser\u00E1 afetada por essa adi\u00E7\u00E3o. Isso pode ser \u00F3timo, mas tamb\u00E9m pode ser ruim. Vamos imaginar uma situa\u00E7\u00E3o ruim:\n\n    O usu\u00E1rio clica no bot\u00E3o \"Comprar\", bot\u00E3o que invoca a fun\u00E7\u00E3o purchase que dispara uma s\u00E9rie de requisi\u00E7\u00F5es e manda o vetor cart para o servidor. Devido a uma conex\u00E3o ruim de internet, a fun\u00E7\u00E3o purchase precisa fazer novamente a requisi\u00E7\u00E3o. Agora, imagine que nesse meio tempo o usu\u00E1rio acidentalmente clique no bot\u00E3o Adicionar ao carrinho em um produto que ele n\u00E3o queria antes da requisi\u00E7\u00E3o come\u00E7ar. Se isto acontecer e a requisi\u00E7\u00E3o for enviada novamente, ent\u00E3o a fun\u00E7\u00E3o purchase ir\u00E1 enviar acidentalmente o vetor com o novo produto adicionado porque existe uma refer\u00EAncia para o vetor cart que a fun\u00E7\u00E3o addItemToCart modificou adicionando um produto indesejado.\n\n    Uma \u00F3tima solu\u00E7\u00E3o seria que a fun\u00E7\u00E3o addCartToItem sempre clonasse o vetor cart, editasse-o, e ent\u00E3o retornasse seu clone. Isso garante que nenhuma outra fun\u00E7\u00E3o que possua uma refer\u00EAncia para o carrinho de compras seja afetada por qualquer mudan\u00E7a feita.\n\n    Duas ressalvas desta abordagem:\n\n    Podem haver casos onde voc\u00EA realmente quer mudar o objeto de entrada, mas quando voc\u00EA adota este tipo de programa\u00E7\u00E3o, voc\u00EA vai descobrir que estes casos s\u00E3o bastante raros. A maioria das coisas podem ser refatoradas para n\u00E3o terem efeitos colaterais.\n\n    Clonar objetos grandes pode ser bastante caro em termos de desempenho. Com sorte, na pr\u00E1tica isso n\u00E3o \u00E9 um problema, porque existem \u00F3timas bibliotecas que permitem que este tipo de programa\u00E7\u00E3o seja r\u00E1pida e n\u00E3o seja t\u00E3o intensa no uso de mem\u00F3ria quanto seria se voc\u00EA clonasse manualmente objetos e vetores.\n\n    Ruim:\n\n    const addItemToCart = (cart, item) => {\n      cart.push({ item, date: Date.now() });\n    };\n    Bom:\n\n    const addItemToCart = (cart, item) => {\n      return [...cart, { item, date: Date.now() }];\n    };\n    N\u00E3o escreva em fun\u00E7\u00F5es globais\n    Poluir globais \u00E9 uma pratica ruim em JavaScript porque voc\u00EA pode causar conflito com outra biblioteca e o usu\u00E1rio da sua API n\u00E3o faria a menor ideia at\u00E9 que ele tivesse um exce\u00E7\u00E3o sendo levantada em produ\u00E7\u00E3o. Vamos pensar em um exemplo: e se voc\u00EA quisesse estender o m\u00E9todo nativo Array do JavaScript para ter um m\u00E9todo diff que poderia mostrar a diferen\u00E7a entre dois vetores? Voc\u00EA poderia escrever sua nova fun\u00E7\u00E3o em Array.prototype, mas poderia colidir com outra biblioteca que tentou fazer a mesma coisa. E se esta outra biblioteca estava apenas usando diff para achar a diferen\u00E7a entre o primeiro e \u00FAltimo elemento de um vetor? \u00C9 por isso que seria muito melhor usar as classes padr\u00F5es do ES2015/ES6 e apenas estender o Array global.\n\n    Ruim:\n\n    Array.prototype.diff = function diff(comparisonArray) {\n      const hash = new Set(comparisonArray);\n      return this.filter(elem => !hash.has(elem));\n    };\n    Bom:\n\n    class SuperArray extends Array {\n      diff(comparisonArray) {\n        const hash = new Set(comparisonArray);\n        return this.filter(elem => !hash.has(elem));\n      }\n    }\n\n    Favore\u00E7a programa\u00E7\u00E3o funcional sobre programa\u00E7\u00E3o imperativa\n    JavaScript n\u00E3o \u00E9 uma linguagem funcional da mesma forma que Haskell \u00E9, mas tem um toque de funcional em si. Linguagens funcionais s\u00E3o mais limpas e f\u00E1ceis de se testar. Favore\u00E7a esse tipo de programa\u00E7\u00E3o quando puder.\n\n    Ruim:\n\n    const programmerOutput = [\n      {\n        name: 'Uncle Bobby',\n        linesOfCode: 500\n      }, {\n        name: 'Suzie Q',\n        linesOfCode: 1500\n      }, {\n        name: 'Jimmy Gosling',\n        linesOfCode: 150\n      }, {\n        name: 'Gracie Hopper',\n        linesOfCode: 1000\n      }\n    ];\n\n    let totalOutput = 0;\n\n    for (let i = 0; i < programmerOutput.length; i++) {\n      totalOutput += programmerOutput[i].linesOfCode;\n    }\n    Bom:\n\n    const programmerOutput = [\n      {\n        name: 'Uncle Bobby',\n        linesOfCode: 500\n      }, {\n        name: 'Suzie Q',\n        linesOfCode: 1500\n      }, {\n        name: 'Jimmy Gosling',\n        linesOfCode: 150\n      }, {\n        name: 'Gracie Hopper',\n        linesOfCode: 1000\n      }\n    ];\n\n    const INITIAL_VALUE = 0;\n\n    const totalOutput = programmerOutput\n      .map((programmer) => programmer.linesOfCode)\n      .reduce((acc, linesOfCode) => acc + linesOfCode, INITIAL_VALUE);\n    arrow_up volta ao topo\n\n    Encapsule condicionais\n    Ruim:\n\n    if (fsm.state === 'fetching' && isEmpty(listNode)) {\n      // ...\n    }\n    Bom:\n\n    function shouldShowSpinner(fsm, listNode) {\n      return fsm.state === 'fetching' && isEmpty(listNode);\n    }\n\n    if (shouldShowSpinner(fsmInstance, listNodeInstance)) {\n      // ...\n    }\n\n    Evite nega\u00E7\u00F5es de condicionais\n    Ruim:\n\n    function isDOMNodeNotPresent(node) {\n      // ...\n    }\n\n    if (!isDOMNodeNotPresent(node)) {\n      // ...\n    }\n    Bom:\n\n    function isDOMNodePresent(node) {\n      // ...\n    }\n\n    if (isDOMNodePresent(node)) {\n      // ...\n    }\n\n    Evite condicionais\n    Esta parece ser uma tarefa imposs\u00EDvel. Da primeira vez que as pessoas escutam isso, a maioria diz, \u201Ccomo eu supostamente faria alguma coisa sem usar if? \u201D A resposta \u00E9 que voc\u00EA pode usar polimorfismo para realizar a mesma tarefa em diversos casos. A segunda quest\u00E3o \u00E9 geralmente, \u201Cbom, isso \u00E9 \u00F3timo, mas porque eu deveria fazer isso?\u201D A resposta \u00E9 um conceito de c\u00F3digo limpo aprendido previamente: uma fun\u00E7\u00E3o deve fazer apenas uma coisa. Quando voc\u00EA tem classes e fun\u00E7\u00F5es que tem declara\u00E7\u00F5es if, voc\u00EA esta dizendo para seu usu\u00E1rio que sua fun\u00E7\u00E3o faz mais de uma coisa. Relembre-se, apenas uma coisa.\n\n    Ruim:\n\n    class Airplane {\n      // ...\n      getCruisingAltitude() {\n        switch (this.type) {\n          case '777':\n            return this.getMaxAltitude() - this.getPassengerCount();\n          case 'Air Force One':\n            return this.getMaxAltitude();\n          case 'Cessna':\n            return this.getMaxAltitude() - this.getFuelExpenditure();\n        }\n      }\n    }\n    Bom:\n\n    class Airplane {\n      // ...\n    }\n\n    class Boeing777 extends Airplane {\n      // ...\n      getCruisingAltitude() {\n        return this.getMaxAltitude() - this.getPassengerCount();\n      }\n    }\n\n    class AirForceOne extends Airplane {\n      // ...\n      getCruisingAltitude() {\n        return this.getMaxAltitude();\n      }\n    }\n\n    class Cessna extends Airplane {\n      // ...\n      getCruisingAltitude() {\n        return this.getMaxAltitude() - this.getFuelExpenditure();\n      }\n    }\n\n    Evite checagem de tipos (parte 1)\n    JavaScript n\u00E3o possui tipos, o que significa que suas fun\u00E7\u00F5es podem receber qualquer tipo de argumento. Algumas vezes esta liberdade pode te morder, e se torna tentador fazer checagem de tipos em suas fun\u00E7\u00F5es. Existem muitas formas de evitar ter que fazer isso. A primeira coisa a se considerar s\u00E3o APIs consistentes.\n\n    Ruim:\n\n    function travelToTexas(vehicle) {\n      if (vehicle instanceof Bicycle) {\n        vehicle.pedal(this.currentLocation, new Location('texas'));\n      } else if (vehicle instanceof Car) {\n        vehicle.drive(this.currentLocation, new Location('texas'));\n      }\n    }\n    Bom:\n\n    function travelToTexas(vehicle) {\n      vehicle.move(this.currentLocation, new Location('texas'));\n    }\n\n    Evite checagem de tipos (parte 2)\n    Se voc\u00EA estiver trabalhando com valores primitivos b\u00E1sicos como strings e inteiros, e voc\u00EA n\u00E3o pode usar polimorfismo, mas ainda sente a necessidade de checar o tipo, voc\u00EA deveria considerar usar TypeScript. \u00C9 uma excelente alternativa para o JavaScript normal, j\u00E1 que fornece uma tipagem est\u00E1tica sobre a sintaxe padr\u00E3o do JavaScript. O problema com checagem manual em JavaScript \u00E9 que para se fazer bem feito requer tanta verborragia extra que a falsa \u201Ctipagem-segura\u201D que voc\u00EA consegue n\u00E3o compensa pela perca de legibilidade. Mantenha seu JavaScript limpo, escreve bons testes, e tenha boas revis\u00F5es de c\u00F3digo. Ou, de outra forma, fa\u00E7a tudo isso mas com TypeScript (que, como eu falei, \u00E9 uma \u00F3tima alternativa!).\n\n    Ruim:\n\n    function combine(val1, val2) {\n      if (typeof val1 === 'number' && typeof val2 === 'number' ||\n          typeof val1 === 'string' && typeof val2 === 'string') {\n        return val1 + val2;\n      }\n\n      throw new Error('Must be of type String or Number');\n    }\n    Bom:\n\n    function combine(val1, val2) {\n      return val1 + val2;\n    }\n\n    N\u00E3o otimize demais\n    Navegadores modernos fazem muitas otimiza\u00E7\u00F5es por debaixo dos panos em tempo de execu\u00E7\u00E3o. Muitas vezes, se voc\u00EA estiver otimizando, est\u00E1 apenas perdendo o seu tempo. Existem bons recursos para se verificar onde falta otimiza\u00E7\u00E3o. Foque nesses por enquanto, at\u00E9 que eles sejam consertados caso seja poss\u00EDvel.\n\n    Ruim:\n\n    // Em navegadores antigos, cada itera\u00E7\u00E3o de 'list.length' n\u00E3o cacheada seria custosa\n    // devido a recomputa\u00E7\u00E3o de 'list.length'. Em navegadores modernos, isto \u00E9 otimizado.\n    for (let i = 0, len = list.length; i < len; i++) {\n      // ...\n    }\n    Bom:\n\n    for (let i = 0; i < list.length; i++) {\n      // ...\n    }\n\n    Remova c\u00F3digo morto\n    C\u00F3digo morto \u00E9 t\u00E3o ruim quanto c\u00F3digo duplicado. N\u00E3o existe nenhum motivo para deix\u00E1-lo em seu c\u00F3digo. Se ele n\u00E3o estiver sendo chamado, livre-se dele. Ele ainda estar\u00E1 a salvo no seu hist\u00F3rico de versionamento se ainda precisar dele.\n\n    Ruim:\n\n    function oldRequestModule(url) {\n      // ...\n    }\n\n    function newRequestModule(url) {\n      // ...\n    }\n\n    const req = newRequestModule;\n    inventoryTracker('apples', req, 'www.inventory-awesome.io');\n    Bom:\n\n    function newRequestModule(url) {\n      // ...\n    }\n\n    const req = newRequestModule;\n    inventoryTracker('apples', req, 'www.inventory-awesome.io');\n"
    },
    oed: {
        title: "Objetos e Estruturas de Dados",
        content: "\n     Objetos e Estruturas de Dados\n     Use getters e setters\n     Usar getters e setters para acessar dados em objetos \u00E9 bem melhor que simplesmente procurar por uma propriedade em um objeto. \"Por qu\u00EA?\", voc\u00EA deve perguntar. Bem, aqui vai uma lista desorganizada de motivos:\n     \n     Quando voc\u00EA quer fazer mais al\u00E9m de pegar (get) a propriedade de um objeto, voc\u00EA n\u00E3o tem que procurar e mudar todos os acessores do seu c\u00F3digo;\n     Torna mais f\u00E1cil fazer valida\u00E7\u00E3o quando estiver dando um set;\n     Encapsula a representa\u00E7\u00E3o interna;\n     Mais f\u00E1cil de adicionar logs e tratamento de erros quando dando get and set;\n     Voc\u00EA pode usar lazy loading nas propriedades de seu objeto, digamos, por exemplo, pegando ele de um servidor.\n     Ruim:\n     \n     function makeBankAccount() {\n       // ...\n     \n       return {\n         balance: 0,\n         // ...\n       };\n     }\n     \n     const account = makeBankAccount();\n     account.balance = 100;\n     Bom:\n     \n     function makeBankAccount() {\n       // este \u00E9 privado\n       let balance = 0;\n     \n       // um \"getter\", feito p\u00FAblico atrav\u00E9s do objeto retornado abaixo\n       function getBalance() {\n         return balance;\n       }\n     \n       // um \"setter\", feito p\u00FAblico atrav\u00E9s do objeto retornado abaixo\n       function setBalance(amount) {\n         // ... validate before updating the balance\n         balance = amount;\n       }\n     \n       return {\n         // ...\n         getBalance,\n         setBalance,\n       };\n     }\n     \n     const account = makeBankAccount();\n     account.setBalance(100);\n     \n     Fa\u00E7a objetos terem membros privados\n     Isto pode ser alcan\u00E7ado atrav\u00E9s de closures (para ES5 e al\u00E9m).\n     \n     Ruim:\n     \n     const Employee = function(name) {\n       this.name = name;\n     };\n     \n     Employee.prototype.getName = function getName() {\n       return this.name;\n     };\n     \n     const employee = new Employee('John Doe');\n     console.log('Employee name: ${employee.getName()}'); // Employee name: John Doe\n     delete employee.name;\n     console.log('Employee name: ${employee.getName()}'); // Employee name: undefined\n     Bom:\n     \n     function makeEmployee(name) {\n       return {\n         getName() {\n           return name;\n         },\n       };\n     }\n     \n     const employee = makeEmployee('John Doe');\n     console.log('Employee name: ${employee.getName()}'); // Employee name: John Doe\n     delete employee.name;\n     console.log('Employee name: ${employee.getName()}'); // Employee name: John Doe \n    "
    },
    classes: {
        title: "Classes",
        content: "\n     Classes\n     Prefira classes do ES2015/ES6 ao inv\u00E9s de fun\u00E7\u00F5es simples do ES5\n     \u00C9 muito dif\u00EDcil conseguir que heran\u00E7a de classe, construtores, e defini\u00E7\u00F5es de m\u00E9todos sejam leg\u00EDveis para classes de ES5 cl\u00E1ssicas. Se voc\u00EA precisa de heran\u00E7a (e esteja ciente que voc\u00EA talvez n\u00E3o precise), ent\u00E3o prefira classes ES2015/ES6. Entretanto, prefira fun\u00E7\u00F5es pequenas ao inv\u00E9s de classes at\u00E9 que voc\u00EA precise de objetos maiores e mais complexos.\n     \n     Ruim:\n     \n     const Animal = function(age) {\n       if (!(this instanceof Animal)) {\n         throw new Error('Instantiate Animal with 'new'');\n       }\n     \n       this.age = age;\n     };\n     \n     Animal.prototype.move = function move() {};\n     \n     const Mammal = function(age, furColor) {\n       if (!(this instanceof Mammal)) {\n         throw new Error('Instantiate Mammal with 'new'');\n       }\n     \n       Animal.call(this, age);\n       this.furColor = furColor;\n     };\n     \n     Mammal.prototype = Object.create(Animal.prototype);\n     Mammal.prototype.constructor = Mammal;\n     Mammal.prototype.liveBirth = function liveBirth() {};\n     \n     const Human = function(age, furColor, languageSpoken) {\n       if (!(this instanceof Human)) {\n         throw new Error('Instantiate Human with 'new'');\n       }\n     \n       Mammal.call(this, age, furColor);\n       this.languageSpoken = languageSpoken;\n     };\n     \n     Human.prototype = Object.create(Mammal.prototype);\n     Human.prototype.constructor = Human;\n     Human.prototype.speak = function speak() {};\n     Bom:\n     \n     class Animal {\n       constructor(age) {\n         this.age = age;\n       }\n     \n       move() { /* ... */ }\n     }\n     \n     class Mammal extends Animal {\n       constructor(age, furColor) {\n         super(age);\n         this.furColor = furColor;\n       }\n     \n       liveBirth() { /* ... */ }\n     }\n     \n     class Human extends Mammal {\n       constructor(age, furColor, languageSpoken) {\n         super(age, furColor);\n         this.languageSpoken = languageSpoken;\n       }\n     \n       speak() { /* ... */ }\n     }\n     \n     Use encadeamento de m\u00E9todos\n     Este padr\u00E3o \u00E9 muito \u00FAtil em JavaScript e voc\u00EA o ver\u00E1 em muitas bibliotecas como jQuery e Lodash. Ele permite que seu c\u00F3digo seja expressivo e menos verboso. Por esse motivo, eu digo, use encadeamento de m\u00E9todos e d\u00EA uma olhada em como o seu c\u00F3digo ficar\u00E1 mais limpo. Em suas fun\u00E7\u00F5es de classes, apenas retorne this no final de cada fun\u00E7\u00E3o, e voc\u00EA poder\u00E1 encadear mais m\u00E9todos de classe nele.\n     \n     Ruim:\n     \n     class Car {\n       constructor(make, model, color) {\n         this.make = make;\n         this.model = model;\n         this.color = color;\n       }\n     \n       setMake(make) {\n         this.make = make;\n       }\n     \n       setModel(model) {\n         this.model = model;\n       }\n     \n       setColor(color) {\n         this.color = color;\n       }\n     \n       save() {\n         console.log(this.make, this.model, this.color);\n       }\n     }\n     \n     const car = new Car('Ford','F-150','red');\n     car.setColor('pink');\n     car.save();\n     Bom:\n     \n     class Car {\n       constructor(make, model, color) {\n         this.make = make;\n         this.model = model;\n         this.color = color;\n       }\n     \n       setMake(make) {\n         this.make = make;\n         // NOTA: Retorne this para encadear\n         return this;\n       }\n     \n       setModel(model) {\n         this.model = model;\n         // NOTA: Retorne this para encadear\n         return this;\n       }\n     \n       setColor(color) {\n         this.color = color;\n         // NOTA: Retorne this para encadear\n         return this;\n       }\n     \n       save() {\n         console.log(this.make, this.model, this.color);\n         // NOTA: Retorne this para encadear\n         return this;\n       }\n     }\n     \n     const car = new Car('Ford','F-150','red')\n       .setColor('pink')\n       .save();\n     \n     Prefira composi\u00E7\u00E3o ao inv\u00E9s de heran\u00E7a\n     Como dito famosamente em Padr\u00E3o de projeto pela Gangue dos Quatro, voc\u00EA deve preferir composi\u00E7\u00E3o sobre heran\u00E7a onde voc\u00EA puder. Existem muitas boas raz\u00F5es para usar heran\u00E7a e muitas boas raz\u00F5es para se usar composi\u00E7\u00E3o. O ponto principal para essa m\u00E1xima \u00E9 que se sua mente for instintivamente para a heran\u00E7a, tente pensar se composi\u00E7\u00E3o poderia modelar melhor o seu problema. Em alguns casos pode.\n     \n     Voc\u00EA deve estar pensando ent\u00E3o, \"quando eu deveria usar heran\u00E7a?\" Isso depende especificamente do seu problema, mas essa \u00E9 uma lista decente de quando heran\u00E7a faz mais sentido que composi\u00E7\u00E3o:\n     \n     Sua heran\u00E7a representa uma rela\u00E7\u00E3o de \"isto-\u00E9\" e n\u00E3o uma rela\u00E7\u00E3o de \"isto-tem\" (Human\u2192Animal vs. User->UserDetails)\n     Voc\u00EA pode reutilizar c\u00F3digo de classes de base (Humanos podem se mover como todos os animais).\n     Voc\u00EA quer fazer mudan\u00E7as globais para classes derivadas mudando apenas a classe base. (Mudar o custo cal\u00F3rico para todos os animais quando se movem).\n     Ruim:\n     \n     class Employee {\n       constructor(name, email) {\n         this.name = name;\n         this.email = email;\n       }\n     \n       // ...\n     }\n     \n     // Ruim porque Employees (Empregados) \"tem\" dados de impostos. EmployeeTaxData n\u00E3o \u00E9 um tipo de Employee\n     class EmployeeTaxData extends Employee {\n       constructor(ssn, salary) {\n         super();\n         this.ssn = ssn;\n         this.salary = salary;\n       }\n     \n       // ...\n     }\n     Bom:\n     \n     class EmployeeTaxData {\n       constructor(ssn, salary) {\n         this.ssn = ssn;\n         this.salary = salary;\n       }\n     \n       // ...\n     }\n     \n     class Employee {\n       constructor(name, email) {\n         this.name = name;\n         this.email = email;\n       }\n     \n       setTaxData(ssn, salary) {\n         this.taxData = new EmployeeTaxData(ssn, salary);\n       }\n       // ...\n     }\n      \n    "
    },
    solid: {
        title: "SOLID",
        content: "\n     SOLID\n     Princ\u00EDpio da Responsabilidade \u00DAnica (SRP)\n     Como dito em C\u00F3digo Limpo, \"Nunca deveria haver mais de um motivo para uma classe ter que mudar\". \u00C9 tentador empacotar uma classe em excesso com muitas funcionalidades, como quando voc\u00EA pode levar apenas uma mala em seu voo. O problema com isso \u00E9 que sua classe n\u00E3o ser\u00E1 conceitualmente coesa e dar-lhe-\u00E1 diversos motivos para mud\u00E1-la. Minimizar o n\u00FAmero de vezes que voc\u00EA precisa mudar uma classe \u00E9 importante, porque, se muitas funcionalidades est\u00E3o em uma classe e voc\u00EA mudar uma por\u00E7\u00E3o dela, pode ser dif\u00EDcil entender como isto afetar\u00E1 outras m\u00F3dulos que dependem dela no seu c\u00F3digo.\n     \n     Ruim:\n     \n     class UserSettings {\n       constructor(user) {\n         this.user = user;\n       }\n     \n       changeSettings(settings) {\n         if (this.verifyCredentials()) {\n           // ...\n         }\n       }\n     \n       verifyCredentials() {\n         // ...\n       }\n     }\n     Bom:\n     \n     class UserAuth {\n       constructor(user) {\n         this.user = user;\n       }\n     \n       verifyCredentials() {\n         // ...\n       }\n     }\n     \n     \n     class UserSettings {\n       constructor(user) {\n         this.user = user;\n         this.auth = new UserAuth(user);\n       }\n     \n       changeSettings(settings) {\n         if (this.auth.verifyCredentials()) {\n           // ...\n         }\n       }\n     }\n     \n     Princ\u00EDpio do Aberto/Fechado (OCP)\n     Como foi dito por Bertrand Meyer, \"entidades de software (classes, m\u00F3dulos, fun\u00E7\u00F5es, etc.) devem se manter abertas para extens\u00F5es, mas fechadas para modifica\u00E7\u00F5es.\" Mas o que isso significa? Esse princ\u00EDpio basicamente diz que voc\u00EA deve permitir que usu\u00E1rios adicionem novas funcionalidades sem mudar c\u00F3digo j\u00E1 existente.\n     \n     Ruim:\n     \n     class AjaxAdapter extends Adapter {\n       constructor() {\n         super();\n         this.name = 'ajaxAdapter';\n       }\n     }\n     \n     class NodeAdapter extends Adapter {\n       constructor() {\n         super();\n         this.name = 'nodeAdapter';\n       }\n     }\n     \n     class HttpRequester {\n       constructor(adapter) {\n         this.adapter = adapter;\n       }\n     \n       fetch(url) {\n         if (this.adapter.name === 'ajaxAdapter') {\n           return makeAjaxCall(url).then((response) => {\n             // transforma a resposta e retorna\n           });\n         } else if (this.adapter.name === 'httpNodeAdapter') {\n           return makeHttpCall(url).then((response) => {\n             // transforma a resposta e retorna\n           });\n         }\n       }\n     }\n     \n     function makeAjaxCall(url) {\n       // faz a request e retorna a promessa\n     }\n     \n     function makeHttpCall(url) {\n       // faz a request e retorna a promessa\n     }\n     Bom:\n     \n     class AjaxAdapter extends Adapter {\n       constructor() {\n         super();\n         this.name = 'ajaxAdapter';\n       }\n     \n       request(url) {\n         // faz a request e retorna a promessa\n       }\n     }\n     \n     class NodeAdapter extends Adapter {\n       constructor() {\n         super();\n         this.name = 'nodeAdapter';\n       }\n     \n       request(url) {\n         // faz a request e retorna a promessa\n       }\n     }\n     \n     class HttpRequester {\n       constructor(adapter) {\n         this.adapter = adapter;\n       }\n     \n       fetch(url) {\n         return this.adapter.request(url).then((response) => {\n           // transforma a resposta e retorna\n         });\n       }\n     }\n     \n     Princ\u00EDpio de Substitui\u00E7\u00E3o de Liskov (LSP)\n     Esse \u00E9 um termo assustador para um conceito extremamente simples. \u00C9 formalmente definido como \u201CSe S \u00E9 um subtipo de T, ent\u00E3o objetos do tipo T podem ser substitu\u00EDdos por objetos com o tipo S (i.e., objetos do tipo S podem substituir objetos do tipo T) sem alterar nenhuma das propriedades desej\u00E1veis de um programa (corretude, desempenho em tarefas, etc.).\u201D Esta \u00E9 uma defini\u00E7\u00E3o ainda mais assustadora.\n     \n     A melhor explica\u00E7\u00E3o para este conceito \u00E9 se voc\u00EA tiver uma classe pai e uma classe filha, ent\u00E3o a classe base e a classe filha pode ser usadas indistintamente sem ter resultados incorretos. Isso ainda pode ser confuso, ent\u00E3o vamos dar uma olhada no exemplo cl\u00E1ssico do Quadrado-Ret\u00E2ngulo (Square-Rectangle). Matematicamente, um quadrado \u00E9 um ret\u00E2ngulo, mas se voc\u00EA model\u00E1-lo usando uma rela\u00E7\u00E3o \u201Cisto-\u00E9\u201D atrav\u00E9s de heran\u00E7a, voc\u00EA rapidamente ter\u00E1 problemas.\n     \n     Ruim:\n     \n     class Rectangle {\n       constructor() {\n         this.width = 0;\n         this.height = 0;\n       }\n     \n       setColor(color) {\n         // ...\n       }\n     \n       render(area) {\n         // ...\n       }\n     \n       setWidth(width) {\n         this.width = width;\n       }\n     \n       setHeight(height) {\n         this.height = height;\n       }\n     \n       getArea() {\n         return this.width * this.height;\n       }\n     }\n     \n     class Square extends Rectangle {\n       setWidth(width) {\n         this.width = width;\n         this.height = width;\n       }\n     \n       setHeight(height) {\n         this.width = height;\n         this.height = height;\n       }\n     }\n     \n     function renderLargeRectangles(rectangles) {\n       rectangles.forEach((rectangle) => {\n         rectangle.setWidth(4);\n         rectangle.setHeight(5);\n         const area = rectangle.getArea(); // RUIM: Retorna 25 para o Quadrado. Deveria ser 20.\n         rectangle.render(area);\n       });\n     }\n     \n     const rectangles = [new Rectangle(), new Rectangle(), new Square()];\n     renderLargeRectangles(rectangles);\n     Bom:\n     \n     class Shape {\n       setColor(color) {\n         // ...\n       }\n     \n       render(area) {\n         // ...\n       }\n     }\n     \n     class Rectangle extends Shape {\n       constructor(width, height) {\n         super();\n         this.width = width;\n         this.height = height;\n       }\n     \n       getArea() {\n         return this.width * this.height;\n       }\n     }\n     \n     class Square extends Shape {\n       constructor(length) {\n         super();\n         this.length = length;\n       }\n     \n       getArea() {\n         return this.length * this.length;\n       }\n     }\n     \n     function renderLargeShapes(shapes) {\n       shapes.forEach((shape) => {\n         const area = shape.getArea();\n         shape.render(area);\n       });\n     }\n     \n     const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];\n     renderLargeShapes(shapes);\n     \n     Princ\u00EDpio da Segrega\u00E7\u00E3o de Interface (ISP)\n     JavaScript n\u00E3o possui interfaces ent\u00E3o esse princ\u00EDpio n\u00E3o se aplica estritamente como os outros. Entretanto, \u00E9 importante e relevante at\u00E9 mesmo com a falta de um sistema de tipos em JavaScript.\n     \n     ISP diz que \"Clientes n\u00E3o devem ser forcados a depender de interfaces que eles n\u00E3o usam.\" Interfaces s\u00E3o contratos impl\u00EDcitos em JavaScript devido a sua tipagem pato (duck typing).\n     \n     Um bom exemplo para se observar que demonstra esse princ\u00EDpio em JavaScript \u00E9 de classes que requerem objetos de configura\u00E7\u00F5es grandes. N\u00E3o pedir para clientes definirem grandes quantidades de op\u00E7\u00F5es \u00E9 ben\u00E9fico, porque na maioria das vezes eles n\u00E3o precisar\u00E3o de todas as configura\u00E7\u00F5es. Torn\u00E1-las opcionais ajuda a prevenir uma \u201Cinterfer\u00EAncia gorda\u201D.\n     \n     Ruim:\n     \n     class DOMTraverser {\n       constructor(settings) {\n         this.settings = settings;\n         this.setup();\n       }\n     \n       setup() {\n         this.rootNode = this.settings.rootNode;\n         this.animationModule.setup();\n       }\n     \n       traverse() {\n         // ...\n       }\n     }\n     \n     const $ = new DOMTraverser({\n       rootNode: document.getElementsByTagName('body'),\n       animationModule() {} //  Na maioria das vezes, n\u00E3o precisamos animar enquanto atravessamos (traversing).\n       // ...\n     });\n     Bom:\n     \n     class DOMTraverser {\n       constructor(settings) {\n         this.settings = settings;\n         this.options = settings.options;\n         this.setup();\n       }\n     \n       setup() {\n         this.rootNode = this.settings.rootNode;\n         this.setupOptions();\n       }\n     \n       setupOptions() {\n         if (this.options.animationModule) {\n           // ...\n         }\n       }\n     \n       traverse() {\n         // ...\n       }\n     }\n     \n     const $ = new DOMTraverser({\n       rootNode: document.getElementsByTagName('body'),\n       options: {\n         animationModule() {}\n       }\n     });\n     \n     Princ\u00EDpio da Invers\u00E3o de Depend\u00EAncia (DIP)\n     Este princ\u00EDpio nos diz duas coisas essenciais:\n     \n     M\u00F3dulos de alto n\u00EDvel n\u00E3o devem depender de m\u00F3dulos de baixo n\u00EDvel. Ambos devem depender de abstra\u00E7\u00F5es.\n     Abstra\u00E7\u00F5es n\u00E3o devem depender de detalhes. Detalhes devem depender de abstra\u00E7\u00F5es.\n     Isso pode ser dif\u00EDcil de entender a princ\u00EDpio, mas se voc\u00EA j\u00E1 trabalhou com AngularJS, voc\u00EA j\u00E1 viu uma implementa\u00E7\u00E3o deste princ\u00EDpio na forma de inje\u00E7\u00E3o de depend\u00EAncia (DI). Apesar de n\u00E3o serem conceitos id\u00EAnticos, DIP n\u00E3o deixa m\u00F3dulos de alto n\u00EDvel saber os detalhes de seus m\u00F3dulos de baixo n\u00EDvel, assim como configur\u00E1-los. Isso pode ser alcan\u00E7ado atrav\u00E9s de DI. Um grande beneficio \u00E9 que reduz o acoplamento entre os m\u00F3dulos. Acoplamento \u00E9 um padr\u00E3o de desenvolvimento muito ruim porque torna seu c\u00F3digo mais dif\u00EDcil de ser refatorado.\n     \n     Como dito anteriormente, JavaScript n\u00E3o possui interfaces, ent\u00E3o as abstra\u00E7\u00F5es que s\u00E3o necess\u00E1rias s\u00E3o contratos impl\u00EDcitos. Que quer dizer que, os m\u00E9todos e as classes que um objeto/classe exp\u00F5e para outros objeto/classe. No exemplo abaixo, o contrato impl\u00EDcito \u00E9 que qualquer m\u00F3dulo de Request para InventoryTracker ter\u00E1 um m\u00E9todo requestItems:\n     \n     Ruim:\n     \n     class InventoryRequester {\n       constructor() {\n         this.REQ_METHODS = ['HTTP'];\n       }\n     \n       requestItem(item) {\n         // ...\n       }\n     }\n     \n     class InventoryTracker {\n       constructor(items) {\n         this.items = items;\n     \n         // Ruim: N\u00F3s criamos uma depend\u00EAncia numa implementa\u00E7\u00E3o de request especifica.\n         // N\u00F3s deveriamos apenas ter requestItems dependendo de um m\u00E9todo de request: 'request'\n         this.requester = new InventoryRequester();\n       }\n     \n       requestItems() {\n         this.items.forEach((item) => {\n           this.requester.requestItem(item);\n         });\n       }\n     }\n     \n     const inventoryTracker = new InventoryTracker(['apples', 'bananas']);\n     inventoryTracker.requestItems();\n     Bom:\n     \n     class InventoryTracker {\n       constructor(items, requester) {\n         this.items = items;\n         this.requester = requester;\n       }\n     \n       requestItems() {\n         this.items.forEach((item) => {\n           this.requester.requestItem(item);\n         });\n       }\n     }\n     \n     class InventoryRequesterV1 {\n       constructor() {\n         this.REQ_METHODS = ['HTTP'];\n       }\n     \n       requestItem(item) {\n         // ...\n       }\n     }\n     \n     class InventoryRequesterV2 {\n       constructor() {\n         this.REQ_METHODS = ['WS'];\n       }\n     \n       requestItem(item) {\n         // ...\n       }\n     }\n     \n     // Construindo nossas depend\u00EAncias externamente e injetando-as, podemos facilmente\n     // substituir nosso m\u00F3dulo de request por um novo mais chique que usa WebSockets\n     const inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());\n     inventoryTracker.requestItems();\n      \n    "
    },
    testes: {
        title: "Testes",
        content: "\n     Testes\n     Testes s\u00E3o mais importantes que entregas. Se voc\u00EA n\u00E3o possui testes ou um quantidade inadequada, ent\u00E3o toda vez que voc\u00EA entregar seu c\u00F3digo voc\u00EA n\u00E3o ter\u00E1 certeza se voc\u00EA n\u00E3o quebrou alguma coisa. Decidir o que constitui uma quantidade adequada \u00E9 responsabilidade do seu time, mas ter 100% de cobertura (todas as senten\u00E7as e branches) \u00E9 a maneira que se alcan\u00E7a uma alta confian\u00E7a e uma paz de espirito em desenvolvimento. Isso quer dizer que al\u00E9m de ter um \u00F3timo framework de testes, voc\u00EA tamb\u00E9m precisa usar uma boa ferramenta de cobertura.\n     \n     N\u00E3o existe desculpa para n\u00E3o escrever testes. Existem diversos frameworks de testes em JS \u00F3timos, ent\u00E3o encontre um que seu time prefira. Quando voc\u00EA encontrar um que funciona para seu time, ent\u00E3o tenha como objetivo sempre escrever testes para cada nova funcionalidade/m\u00F3dulo que voc\u00EA introduzir. Se seu m\u00E9todo preferido for Desenvolvimento Orientado a Testes (TDD), isso \u00E9 \u00F3timo, mas o ponto principal \u00E9 apenas ter certeza que voc\u00EA est\u00E1 alcan\u00E7ado suas metas de cobertura antes de lan\u00E7ar qualquer funcionalidade, ou refatorar uma j\u00E1 existente.\n     \n     Um conceito por teste\n     Ruim:\n     \n     import assert from 'assert';\n     \n     describe('MakeMomentJSGreatAgain', () => {\n       it('handles date boundaries', () => {\n         let date;\n     \n         date = new MakeMomentJSGreatAgain('1/1/2015');\n         date.addDays(30);\n         assert.equal('1/31/2015', date);\n     \n         date = new MakeMomentJSGreatAgain('2/1/2016');\n         date.addDays(28);\n         assert.equal('02/29/2016', date);\n     \n         date = new MakeMomentJSGreatAgain('2/1/2015');\n         date.addDays(28);\n         assert.equal('03/01/2015', date);\n       });\n     });\n     Bom:\n     \n     import assert from 'assert';\n     \n     describe('MakeMomentJSGreatAgain', () => {\n       it('handles 30-day months', () => {\n         const date = new MakeMomentJSGreatAgain('1/1/2015');\n         date.addDays(30);\n         assert.equal('1/31/2015', date);\n       });\n     \n       it('handles leap year', () => {\n         const date = new MakeMomentJSGreatAgain('2/1/2016');\n         date.addDays(28);\n         assert.equal('02/29/2016', date);\n       });\n     \n       it('handles non-leap year', () => {\n         const date = new MakeMomentJSGreatAgain('2/1/2015');\n         date.addDays(28);\n         assert.equal('03/01/2015', date);\n       });\n     });\n      \n    "
    },
    concorrencia: {
        title: "Concorrência",
        content: "\n     Concorr\u00EAncia\n     Use Promessas, n\u00E3o callbacks\n     Callbacks n\u00E3o s\u00E3o limpos, e eles causam uma quantidade excessiva de aninhamentos. A partir de ES2015/ES6, Promessas s\u00E3o um tipo nativo global. Use-as!\n     \n     Ruim:\n     \n     import { get } from 'request';\n     import { writeFile } from 'fs';\n     \n     get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin', (requestErr, response) => {\n       if (requestErr) {\n         console.error(requestErr);\n       } else {\n         writeFile('article.html', response.body, (writeErr) => {\n           if (writeErr) {\n             console.error(writeErr);\n           } else {\n             console.log('File written');\n           }\n         });\n       }\n     });\n     Bom:\n     \n     import { get } from 'request';\n     import { writeFile } from 'fs';\n     \n     get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin')\n       .then((response) => {\n         return writeFile('article.html', response);\n       })\n       .then(() => {\n         console.log('File written');\n       })\n       .catch((err) => {\n         console.error(err);\n       });\n     arrow_up voltar ao topo\n     \n     Async/Await s\u00E3o ainda mais limpas que Promessas\n     Promessas s\u00E3o uma alternativa bem mais limpa que callbacks, mas o ES2017/ES8 traz async e await que oferecem uma solu\u00E7\u00E3o ainda mais limpa. Tudo o que voc\u00EA precisa \u00E9 uma fun\u00E7\u00E3o que tem como prefixo a palavra-chave async, e ent\u00E3o voc\u00EA pode escrever sua logica imperativamente sem usar then para encadear suas fun\u00E7\u00F5es. Use isto se voc\u00EA puder tirar vantagem das funcionalidades do ES2017/ES8 hoje!\n     \n     Ruim:\n     \n     import { get } from 'request-promise';\n     import { writeFile } from 'fs-promise';\n     \n     get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin')\n       .then((response) => {\n         return writeFile('article.html', response);\n       })\n       .then(() => {\n         console.log('File written');\n       })\n       .catch((err) => {\n         console.error(err);\n       });\n     Bom:\n     \n     import { get } from 'request-promise';\n     import { writeFile } from 'fs-promise';\n     \n     async function getCleanCodeArticle() {\n       try {\n         const response = await get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin');\n         await writeFile('article.html', response);\n         console.log('File written');\n       } catch(err) {\n         console.error(err);\n       }\n     }\n      \n    "
    },
    te: {
        title: "Tratamento de Erros",
        content: "\n     Tratamento de Erros\n     throw error \u00E9 uma coisa boa! Eles significam que o programa identificou com sucesso quando algo deu errado e est\u00E1 permitindo que voc\u00EA saiba parando a execu\u00E7\u00E3o da fun\u00E7\u00E3o no processo atual, fechando o processo (em Node), e notificando voc\u00EA no console com a pilha de processos.\n     \n     N\u00E3o ignore erros capturados\n     N\u00E3o fazer nada com um erro capturado n\u00E3o te d\u00E1 a habilidade de resolv\u00EA-lo ou reagir ao erro informado. Exibir um log no console(console.log) n\u00E3o \u00E9 muito melhor porque muitas vezes ele pode ficar perdido entre um monte de outras coisas impressas no console. Se voc\u00EA envolver qualquer peda\u00E7o de c\u00F3digo em um try/catch isso significa que voc\u00EA acredita que um erro pode ocorrer l\u00E1 e ent\u00E3o voc\u00EA deveria ter um plano, ou criar caminho de c\u00F3digo para quando isso ocorrer.\n     \n     Ruim:\n     \n     try {\n       functionThatMightThrow();\n     } catch (error) {\n       console.log(error);\n     }\n     Bom:\n     \n     try {\n       functionThatMightThrow();\n     } catch (error) {\n       // Uma op\u00E7\u00E3o (mais chamativa que console.log):\n       console.error(error);\n       // Outra op\u00E7\u00E3o:\n       notifyUserOfError(error);\n       // Outra op\u00E7\u00E3o:\n       reportErrorToService(error);\n       // OU as tr\u00EAs!\n     }\n     N\u00E3o ignore promessas rejeitadas\n     Pela mesma raz\u00E3o que voc\u00EA n\u00E3o deveria ignorar erros caputados de try/catch\n     \n     Ruim:\n     \n     getdata()\n       .then((data) => {\n         functionThatMightThrow(data);\n       })\n       .catch((error) => {\n         console.log(error);\n       });\n     Bom:\n     \n     getdata()\n       .then((data) => {\n         functionThatMightThrow(data);\n       })\n       .catch((error) => {\n         // One option (more noisy than console.log):\n         console.error(error);\n         // Another option:\n         notifyUserOfError(error);\n         // Another option:\n         reportErrorToService(error);\n         // OR do all three!\n       });\n      \n    "
    },
    formatacao: {
        title: "Formatação",
        content: "\n    Formata\u00E7\u00E3o\n    Formata\u00E7\u00E3o \u00E9 subjetiva. Como muitas regras aqui, n\u00E3o h\u00E1 nenhuma regra fixa e r\u00E1pida que voc\u00EA precisa seguir. O ponto principal \u00E9 N\u00C3O DISCUTA sobre formata\u00E7\u00E3o. Existem muitas ferramentas para automatizar isso. Utilize uma! \u00C9 um desperdicio de tempo e dinheiro para engenheiros discutirem sobre formata\u00E7\u00E3o.\n\n    Para coisas que n\u00E3o possam utilizar formata\u00E7\u00E3o autom\u00E1tica (identa\u00E7\u00E3o, tabs vs. espa\u00E7os, aspas simples vs. duplas, etc.) olhe aqui para alguma orienta\u00E7\u00E3o.\n\n    Utilize capitaliza\u00E7\u00E3o consistente\n    JavaScript n\u00E3o \u00E9 uma linguagem tipada, ent\u00E3o a capitaliza\u00E7\u00E3o diz muito sobre suas vari\u00E1veis, fun\u00E7\u00F5es, etc. Estas regras s\u00E3o subjetivas, ent\u00E3o sua equipe pode escolher o que quiserem. O ponto \u00E9, n\u00E3o importa o que voc\u00EAs todos escolham, apenas seja consistente.\n\n    Ruim:\n\n    const DAYS_IN_WEEK = 7;\n    const daysInMonth = 30;\n\n    const songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];\n    const Artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];\n\n    function eraseDatabase() {}\n    function restore_database() {}\n\n    class animal {}\n    class Alpaca {}\n    Bom:\n\n    const DAYS_IN_WEEK = 7;\n    const DAYS_IN_MONTH = 30;\n\n    const SONGS = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];\n    const ARTISTS = ['ACDC', 'Led Zeppelin', 'The Beatles'];\n\n    function eraseDatabase() {}\n    function restoreDatabase() {}\n\n    class Animal {}\n    class Alpaca {}\n\n    Fun\u00E7\u00F5es e chamadas de fun\u00E7\u00F5es devem estar pr\u00F3ximas\n    Se uma fun\u00E7\u00E3o chamar outra, mantenha estas fun\u00E7\u00F5es verticalmente pr\u00F3ximas no arquivo fonte. Em um cen\u00E1rio ideal, manter a chamada logo acima da fun\u00E7\u00E3o. N\u00F3s tendemos a ler c\u00F3digos de cima para baixo, como num jornal. Por causa disso, fa\u00E7a o seu c\u00F3digo desta maneira.\n\n    Ruim:\n\n    class PerformanceReview {\n      constructor(employee) {\n        this.employee = employee;\n      }\n\n      lookupPeers() {\n        return db.lookup(this.employee, 'peers');\n      }\n\n      lookupManager() {\n        return db.lookup(this.employee, 'manager');\n      }\n\n      getPeerReviews() {\n        const peers = this.lookupPeers();\n        // ...\n      }\n\n      perfReview() {\n        this.getPeerReviews();\n        this.getManagerReview();\n        this.getSelfReview();\n      }\n\n      getManagerReview() {\n        const manager = this.lookupManager();\n      }\n\n      getSelfReview() {\n        // ...\n      }\n    }\n\n    const review = new PerformanceReview(employee);\n    review.perfReview();\n    Bom:\n\n    class PerformanceReview {\n      constructor(employee) {\n        this.employee = employee;\n      }\n\n      perfReview() {\n        this.getPeerReviews();\n        this.getManagerReview();\n        this.getSelfReview();\n      }\n\n      getPeerReviews() {\n        const peers = this.lookupPeers();\n        // ...\n      }\n\n      lookupPeers() {\n        return db.lookup(this.employee, 'peers');\n      }\n\n      getManagerReview() {\n        const manager = this.lookupManager();\n      }\n\n      lookupManager() {\n        return db.lookup(this.employee, 'manager');\n      }\n\n      getSelfReview() {\n        // ...\n      }\n    }\n\n    const review = new PerformanceReview(employee);\n    review.perfReview();\n\n    "
    },
    comentarios: {
        title: "Comentários",
        content: "\n    Coment\u00E1rios\nApenas comente coisas que tenham complexidade de l\u00F3gica de neg\u00F3cio.\nComent\u00E1rios s\u00E3o uma desculpa, n\u00E3o um requisito. Um bom c\u00F3digo documenta-se, a maior parte, por si s\u00F3.\n\nRuim:\n\nfunction hashIt(data) {\n  // A hash\n  let hash = 0;\n\n  // Tamanho da string\n  const length = data.length;\n\n  // Loop em cada caracter da informa\u00E7\u00E3o\n  for (let i = 0; i < length; i++) {\n    // Pega o c\u00F3digo do caracter.\n    const char = data.charCodeAt(i);\n    // Cria a hash\n    hash = ((hash << 5) - hash) + char;\n    // Converte para um integer 32-bit\n    hash &= hash;\n  }\n}\nBom:\n\nfunction hashIt(data) {\n  let hash = 0;\n  const length = data.length;\n\n  for (let i = 0; i < length; i++) {\n    const char = data.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n\n    // Converte para um integer 32-bit\n    hash &= hash;\n  }\n}\narrow_up voltar ao topo\n\nN\u00E3o deixe c\u00F3digo comentado na sua base de c\u00F3digo\nControle de vers\u00E3o existe por uma raz\u00E3o. Deixar c\u00F3digos velhos no seu hist\u00F3rico.\n\nRuim:\n\ndoStuff();\n// doOtherStuff();\n// doSomeMoreStuff();\n// doSoMuchStuff();\nBom:\n\ndoStuff();\narrow_up voltar ao topo\n\nN\u00E3o comente registro de altera\u00E7\u00F5es\nLembre-se, utilize controle de vers\u00E3o! N\u00E3o tem necessidade em deixar c\u00F3digos inutlizados, c\u00F3digos comentados e especialmente registros de altera\u00E7\u00F5es. Utilize git log para pegar o hist\u00F3rico!\n\nRuim:\n\n/**\n * 2016-12-20: Removidas monads, n\u00E3o entendia elas (RM)\n * 2016-10-01: Melhoria utilizando monads especiais (JP)\n * 2016-02-03: Removido checagem de tipos (LI)\n * 2015-03-14: Adicionada checagem de tipos (JR)\n */\nfunction combine(a, b) {\n  return a + b;\n}\nBom:\n\nfunction combine(a, b) {\n  return a + b;\n}\narrow_up voltar ao topo\n\nEvite marcadores de posi\u00E7\u00E3o\nEles geralmente criam ru\u00EDdos. Deixe que as fun\u00E7\u00F5es e nomes de vari\u00E1veis em conjunto com a devida identa\u00E7\u00E3o e formata\u00E7\u00E3o deem a estrutura visual para o seu c\u00F3digo.\n\nRuim:\n\n////////////////////////////////////////////////////////////////////////////////\n// Intancia\u00E7\u00E3o do Scope Model\n////////////////////////////////////////////////////////////////////////////////\n$scope.model = {\n  menu: 'foo',\n  nav: 'bar'\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Configura\u00E7\u00E3o da Action\n////////////////////////////////////////////////////////////////////////////////\nconst actions = function() {\n  // ...\n};\nBom:\n\n$scope.model = {\n  menu: 'foo',\n  nav: 'bar'\n};\n\nconst actions = function() {\n  // ...\n};\n    ",
    },
    reference: {
        title: 'referencia',
        content: "\n    Reposit\u00F3rio original:\n    https://github.com/ryanmcdermott/clean-code-javascript\n    ",
    },
};
exports.default = documentationJS;
